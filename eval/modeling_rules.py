from typing import List, Union
from schemas.eval_utils import EvaluatorViolation
from schemas.eval_model_and_source import DiscoModelNode, DiscoSourceNode


class ModelingRuleSet:
    def __init__(self):
        self.violations: List[EvaluatorViolation, None] = []
        self.rule_map = {
            DiscoModelNode: [self.root_model_rule, self.direct_join_to_source, self.model_fanout, self.multiple_sources_joined],
            DiscoSourceNode: [self.unused_sources, self.source_fanout]
        }

    def root_model_rule(self, model: DiscoModelNode):
        if len(model.parents) == 0:
            self.violations.append(
                EvaluatorViolation.parse_obj({
                    "short_summary":f"{model.name} has no parents and is a root model.",
                    "long_summary":f"""{model.name} has no parents and is a root model. This likely means that the model contains raw table references, either to a raw data source, or another model in the project without using the `{{ source() }}` or `{{ ref() }}` functions, respectively. This means that dbt is unable to interpret the correct lineage of this model, and could result in mis-timed execution and/or circular references depending on the models upstream dependencies.""",
                    "model":model.name,
                    "unique_id":model.uniqueId,
                    "severity":"medium",
                    "rule_set":"DAG Structure",
                    "rule_name":"Root Model",
                    "exceptions": "This behavior may be observed in the case of a manually defined reference table that does not have any dependencies. A good example of this is a dim_calendar table that is generated by the `{{ dbt_utils.date_spine() }}` macro — this SQL logic is completely self contained, and does not require any external data sources to execute."
                })
            )

    def direct_join_to_source(self, model: DiscoModelNode):
        model_parents = [parent.name for parent in model.parents if parent.uniqueId.startswith("model")]
        source_parents = [parent.name for parent in model.parents if parent.uniqueId.startswith("source")]
        if len(model_parents) > 0 and len(source_parents) > 0:
            self.violations.append(
                EvaluatorViolation.parse_obj({
                    "short_summary":f"{model.name} references both a model and a source node.",
                    "long_summary":f"""{model.name} references both a model and a source node. 
                        We highly recommend having a one-to-one relationship between sources and their corresponding staging model, and not having any other model reading from the source. 
                        Those staging models are then the ones read from by the other downstream models.
                        This allows renaming your columns and doing minor transformation on your source data only once and being consistent across all the models that will consume the source data.""",
                    "model":model.name,
                    "unique_id":model.uniqueId,
                    "severity":"high",
                    "rule_set":"DAG Structure",
                    "rule_name":"Direct Join to Source",
                    "exceptions": ""
                })
            )

    def model_fanout(self, model: DiscoModelNode):
        # in real eval, this is a configurable variable
        if len(model.children) > 3:
            self.violations.append(
                EvaluatorViolation.parse_obj({
                    "short_summary":f"{model.name} has more than 3 direct leaf children",
                    "long_summary":f"""{model.name} with more than 3 direct leaf children
                        With this many children, this might indicate some transformations should move to the BI layer, or a common business transformations should be moved upstream.""",
                    "model":model.name,
                    "unique_id":model.uniqueId,
                    "severity":"low",
                    "rule_set":"DAG Structure",
                    "rule_name":"Model Fanout",
                    "exceptions": "Some BI tools are better than others at joining and data exploration. For example, with Looker you could end your DAG after marts (i.e. fcts & dims) and join those artifacts together (with a little know how and setup time) to make your reports. For others, like Tableau, model fanouts might be more beneficial, as this tool prefers big tables over joins, so predefining some reports is usually more performant."
                })
            )
    
    def multiple_sources_joined(self, model: DiscoModelNode):
        # in real eval, this is a configurable variable
        source_parents = [parent.name for parent in model.parents if parent.uniqueId.startswith("source")]
        if len(source_parents) > 1:
            self.violations.append(
                EvaluatorViolation.parse_obj({
                    "short_summary":f"{model.name} joins multiple sources.",
                    "long_summary":f"""{model.name} joins multiple sources. 
                       We very strongly believe that a staging model is the atomic unit of data modeling. 
                       Each staging model bears a one-to-one relationship with the source data table it represents. 
                       With that in mind, two {{ source() }} declarations in one staging model likely means we are not being composable enough and there are individual building blocks which could be broken out into their respective models.""",
                    "model":model.name,
                    "unique_id":model.uniqueId,
                    "severity":"high",
                    "rule_set":"DAG Structure",
                    "rule_name":"Multiple Sources Joined",
                    "exceptions": "Sometimes companies have a bunch of identical sources across systems. When these identical sources will only ever be used collectively, you should union them once and create a staging layer on the combined result."
                })
            )

    def unused_sources(self, source: DiscoSourceNode):
        # in real eval, this is a configurable variable
        if len(source.children) == 0:
            self.violations.append(
                EvaluatorViolation.parse_obj({
                    "short_summary":f"{source.name} is not used.",
                    "long_summary":f"""{source.name} is not used.
                       This represents either a source that you have defined in YML but never brought into a model or a model that was deprecated and the corresponding rows in the source block of the YML file were not deleted at the same time. This simply represents the buildup of cruft in the project that doesn’t need to be there.""",
                    "model":source.name,
                    "unique_id":source.uniqueId,
                    "severity":"medium",
                    "rule_set":"DAG Structure",
                    "rule_name":"Unused Sources",
                    "exceptions": ""
                })
            )

    def source_fanout(self, source: DiscoSourceNode):
        # in real eval, this is a configurable variable
        if len(source.children) > 1:
            self.violations.append(
                EvaluatorViolation.parse_obj({
                    "short_summary":f"{source.name} is the direct parent of multiple resources in the DAG.",
                    "long_summary":f"""{source.name} is the direct parent of multiple resources in the DAG.
                       Each source node should be referenced by a single model that performs basic operations, such as renaming, recasting, and other light transformations to maintain consistency through out the project.""",
                    "model":source.name,
                    "unique_id":source.uniqueId,
                    "severity":"medium",
                    "rule_set":"DAG Structure",
                    "rule_name":"Source Fanout",
                    "exceptions": ""
                })
            )

    def process(self, resource: Union[DiscoModelNode, DiscoSourceNode]):
        rules = self.rule_map[type(resource)]
        for rule in rules:
            rule(resource)
        return self.violations
